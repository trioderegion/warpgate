<!-- start:source.tmpl.hbs -->
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
		<title>lib/PlaceableFit.mjs</title>
		<!--[if lt IE 9]>
		<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
		<![endif]-->
		<link href="https://fonts.googleapis.com/css?family=PT+Mono" rel="stylesheet">
		<link type="text/css" rel="stylesheet" href="css/bootstrap.min.css">
		<link type="text/css" rel="stylesheet" href="css/prism.min.css">
		<link type="text/css" rel="stylesheet" href="css/template.min.css">
			<link type="text/css" rel="stylesheet" href="../../.github/css/foodoc-overrides.css">
		<script type="text/javascript">
			window.TEMPLATE_OPTIONS = {"includeDate":true,"dateFormat":"Do MMM YYYY","systemName":"Warp Gate","systemSummary":"API Documentation","systemLogo":"img/hb-icon.bmp","systemColor":"","navMembers":[{"kind":"global","title":"Types","summary":"Definitions for commonly used api parameters and return values."},{"kind":"namespace","title":"API","summary":"Primary API for warp gate operations."}],"footer":"","copyright":"Warp Gate <a href=\"https://github.com/trioderegion/warpgate/blob/master/LICENSE\">Copyright © 2021</a> Matthew Haentschke","linenums":true,"collapseSymbols":true,"inverseNav":true,"inlineNav":false,"outputSourceFiles":true,"sourceRootPath":null,"disablePackagePath":true,"outputSourcePath":false,"showTableOfContents":true,"showAccessFilter":true,"analytics":null,"methodHeadingReturns":true,"sort":"longname, linenum, version, since","search":true,"favicon":null,"stylesheets":["../../.github/css/foodoc-overrides.css"],"scripts":[],"monospaceLinks":true,"cleverLinks":true};
			window.DOCLET_TOC_ENABLED = false;
			window.DOCLET_AFILTER_ENABLED = false;
		</script>
</head>
<body>
	<!-- start:navbar.hbs -->
	<header class="navbar navbar-default navbar-fixed-top navbar-inverse">
		<div class="container">
			<div class="navbar-header">
				<a class="navbar-brand branding-logo" href="index.html" style="background-image: url(img/hb-icon.bmp);">
					Warp Gate
				</a>
				<!-- displayed on small devices -->
				<button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#topNavigation">
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
				</button>
			</div>
			<div class="navbar-collapse collapse" id="topNavigation">
				<ul class="nav navbar-nav">
								<li class="dropdown">
									<a href="global.html" class="dropdown-toggle" data-toggle="dropdown">Types<b class="caret"></b></a>
									<ul class="dropdown-menu">
											<li><a href="global.html#ComparisonKeys">ComparisonKeys</a></li>
											<li><a href="global.html#CrosshairsConfig">CrosshairsConfig</a></li>
											<li><a href="global.html#CrosshairsData">CrosshairsData</a></li>
											<li><a href="global.html#MutationData">MutationData</a></li>
											<li><a href="global.html#MutationOptions">MutationOptions</a></li>
											<li><a href="global.html#NoticeConfig">NoticeConfig</a></li>
											<li><a href="global.html#ParallelShow">ParallelShow</a></li>
											<li><a href="global.html#PostDelta">PostDelta</a></li>
											<li><a href="global.html#PostMutate">PostMutate</a></li>
											<li><a href="global.html#PostSpawn">PostSpawn</a></li>
											<li><a href="global.html#PreSpawn">PreSpawn</a></li>
											<li><a href="global.html#Shorthand">Shorthand</a></li>
											<li><a href="global.html#SpawningOptions">SpawningOptions</a></li>
											<li><a href="global.html#WarpOptions">WarpOptions</a></li>
											<li><a href="global.html#WorkflowOptions">WorkflowOptions</a></li>
									</ul>
								</li>
								<li class="dropdown">
									<a href="list_namespace.html" class="dropdown-toggle" data-toggle="dropdown">API<b class="caret"></b></a>
									<ul class="dropdown-menu">
											<li><a href="warpgate.html">warpgate</a></li>
											<li><a href="warpgate.abstract.html">warpgate.abstract</a></li>
											<li><a href="warpgate.crosshairs.html">warpgate.crosshairs</a></li>
											<li><a href="warpgate.event.html">warpgate.event</a></li>
											<li><a href="warpgate.plugin.html">warpgate.plugin</a></li>
											<li><a href="warpgate.util.html">warpgate.util</a></li>
									</ul>
								</li>
				</ul>
					<!-- start:lunr-search-navbar.hbs -->
					<form class="navbar-form navbar-right" role="search">
						<div class="input-group">
							<input type="text" class="form-control" placeholder="Search" id="lunr-search-input">
							<div class="input-group-btn">
								<button class="btn btn-default" id="lunr-search-submit">
									<i class="glyphicon glyphicon-search"></i>
								</button>
							</div>
						</div>
					</form>
					<!-- start:lunr-search-navbar.hbs -->		</div>
		</div>
	</header>
	<!-- end:navbar.hbs -->		<div class="page-header">
			<div class="container">
				<span class="kind">source</span>
				<h1><span class="name">lib/PlaceableFit.mjs</span></h1>
			</div>
		</div>
	<div class="container content">
		<div class="row">
			<div class="col-md-12 main-content">
		<section class="source-section">
			<article></article>
			<pre class="prettyprint source language-javascript line-numbers"><code class="language-javascript">import { Propagator } from "./propagator.js";

/**
 * Generator function for exploring vertex-connected grid locations in an
 * outward "ring" pattern.
 *
 * @export
 * @generator
 * @name warpgate.util.RingGenerator
 * @param {{x:Number, y:Number}} origin Staring location (pixels) for search
 * @param {Number} numRings
 * @yields {{x: Number, y: Number}} pixel location of next grid-ring-connected origin
 */
export function* RingGenerator(origin, numRings) {
  const gridLoc = canvas.grid.grid.getGridPositionFromPixels(
    origin.x,
    origin.y
  );

  const positions = new Set();

  const seen = (position) => {
    const key = position.join(".");
    if (positions.has(key)) return true;

    positions.add(key);
    return false;
  };

  seen(gridLoc);
  let queue = [gridLoc];
  let ring = 0;

  /* include seed point in iterator */
  yield { x: origin.x, y: origin.y };

  /* if this is off-grid, also check the snap location */
  const snapped = canvas.grid.getSnappedPosition(origin.x, origin.y);
  const snappedIndex = canvas.grid.grid.getGridPositionFromPixels(
    snapped.x,
    snapped.y
  );
  if (!seen(snappedIndex)) {
    queue = [snappedIndex];
    yield snapped;
  }

  while (queue.length > 0 &amp;&amp; ring &lt; numRings) {
    const next = queue.flatMap((loc) => canvas.grid.grid.getNeighbors(...loc));
    queue = next.filter((loc) => !seen(loc));

    for (const loc of queue) {
      const [x, y] = canvas.grid.grid.getPixelsFromGridPosition(...loc);
      yield { x, y };
    }

    ring += 1;
  }

  return { x: null, y: null };
}

/**
 * Utility class for locating a free area on the grid from
 * a given initial 'requested' position. Effectively slides
 * the requested position to a nearby position free of other
 * tokens (by default, but accepts arbitrary canvas layers with quad trees)
 *
 * @class PlaceableFit
 */
export class PlaceableFit {
  /**
   * Initialize new "fit" search from the provided
   * bounds.
   *
   * @param {{x:Number, y:Number, width:Number, height:Number}} bounds
   * @param {Object} [options]
   * @constructor
   */
  constructor(bounds, options = {}) {
    this.options = {
      avoidWalls: true,
      searchRange: 6,
      visualize: false,
      collisionLayers: [canvas.tokens],
    };

    foundry.utils.mergeObject(this.options, options);

    this.bounds = new PIXI.Rectangle(
      bounds.x,
      bounds.y,
      bounds.width,
      bounds.height
    );

    if (this.options.visualize) canvas.controls?.debug?.clear?.();
  }

  /**
   *
   *
   * @param {{x:Number, y:Number}} newOrigin
   * @returns PIXI.Rectangle bounds for overlap testing (slightly smaller)
   * @memberof PlaceableFit
   */
  _collisionBounds(newOrigin) {
    const newBounds = new PIXI.Rectangle(
      newOrigin.x,
      newOrigin.y,
      this.bounds.width,
      this.bounds.height
    );
    newBounds.pad(-10);
    return newBounds.normalize();
  }

  /**
   * With the provided origin (top left), can this
   * placeable fit without overlapping other placeables?
   *
   * @param {{x: Number, y: Number}} loc Origin of bounds
   * @returns boolean Placeable bounds fit without overlap
   * @memberof PlaceableFit
   */
  spaceClear(loc) {
    const candidateBounds = this._collisionBounds(loc);

    if (this.options.visualize) {
      canvas.controls.debug
        .lineStyle(2, 0xff0000, 0.5)
        .drawShape(candidateBounds);
    }

    for (const layer of this.options.collisionLayers) {
      const hits = layer.quadtree.getObjects(candidateBounds);
      if (hits.size == 0) return true;
    }

    return false;
  }

  /**
   *
   *
   * @param {{x:Number, y:Number}} originalCenter
   * @param {{x:Number, y:Number}} shiftedCenter
   * @returns Boolean resulting shifted position would collide with a move blocking wall
   * @memberof PlaceableFit
   */
  _offsetCollidesWall(originalCenter, shiftedCenter) {
    const collision = CONFIG.Canvas.polygonBackends.move.testCollision(
      originalCenter,
      shiftedCenter,
      { mode: "any", type: "move" }
    );

    return collision;
  }

  /**
   * Searches for and returns the bounds origin point at which it does
   * not overlap other placeables.
   *
   * @returns {{x: Number, y: Number}|undefined} Identified bounds origin free of overlap
   * @memberof PlaceableFit
   */
  find() {
    if (game.release?.generation &lt; 11) {
      return Propagator.getFreePosition(this.bounds, this.bounds);
    }

    const locIter = RingGenerator(this.bounds, this.options.searchRange);

    let testLoc = null;

    const newCenter = (x, y) => ({
      x: x + this.bounds.width / 2,
      y: y + this.bounds.height / 2,
    });

    while (!(testLoc = locIter.next()).done) {
      const { x, y } = testLoc.value;

      let clear = this.spaceClear({ x, y });
      if (clear &amp;&amp; this.options.avoidWalls) {
        clear = !this._offsetCollidesWall(this.bounds.center, newCenter(x, y));
      }

      if (clear) return { x, y };
    }

    return;
  }
}
</code></pre>
		</section>
			</div>
		</div>
	</div>
	<footer>
				<div class="copyright">Warp Gate <a href="https://github.com/trioderegion/warpgate/blob/master/LICENSE">Copyright © 2021</a> Matthew Haentschke</div>
			<div class="generated-by">Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.11</a> on 24th Jul 2023 using the <a href="https://github.com/steveush/foodoc">FooDoc template</a>.</div>
	</footer>
	<script src="js/jquery.min.js"></script>
	<script src="js/bootstrap.min.js"></script>
	<script src="js/clipboard.min.js"></script>
	<script src="js/prism.min.js"></script>
	<script src="js/template.min.js"></script>
		<!-- start:lunr-search-modal.hbs -->
		<div class="modal fade" id="lunr-search-modal">
			<div class="modal-dialog">
				<div class="modal-content">
					<div class="modal-header">
						<button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
						<h4 class="modal-title">Search results</h4>
					</div>
					<div class="modal-body" id="lunr-search-body">
					</div>
					<div class="modal-footer" id="lunr-search-footer">
						<button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
					</div>
				</div><!-- /.modal-content -->
			</div><!-- /.modal-dialog -->
		</div>
		<!-- end:lunr-search-modal.hbs -->		<script src="js/lunr.min.js"></script>
	
</body>
</html>
<!-- end:source.tmpl.hbs -->