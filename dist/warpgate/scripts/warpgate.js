class e{static info(...e){console.log((s?.data?.title??"")+"  | ",...e)}static debug(...e){s.setting("debug")&&console.debug((s?.data?.title??"")+"  | ",...e)}static warn(...e){console.warn((s?.data?.title??"")+" | WARNING | ",...e),ui.notifications.warn(`${s?.data?.title??""} | WARNING | ${e[0]}`)}static error(...e){console.error((s?.data?.title??"")+" | ERROR | ",...e),ui.notifications.error(`${s?.data?.title??""} | ERROR | ${e[0]}`)}static catchThrow(t,a=void 0){console.warn(t),a&&e.error(a)}static register(){this.settings()}static settings(){const e={debug:{scope:"client",config:!0,default:!1,type:Boolean}};s.applySettings(e)}}const t="warpgate",a="/modules/"+t;class s{static data={name:t,path:a,title:"Warp Gate"};static compat(t,a=globalThis){const s=game.release?.generation;switch(t){case"interaction.pointer":return{10:a.canvas.app.renderer.plugins.interaction.mouse}[s]??canvas.app.renderer.plugins.interaction.pointer;case"crosshairs.computeShape":return({10:()=>("circle"!=a.document.t&&e.error("Non-circular Crosshairs is unsupported!"),a._getCircleShape(a.ray.distance))}[s]??(()=>a._computeShape()))();default:return null}}static async register(){e.info("Initializing Module"),s.settings()}static async build(){e.info("Module Data Built")}static setting(e){return game.settings.get(s.data.name,e)}static localize(e){return game.i18n.localize("warpgate."+e)}static format(e,t){return game.i18n.format("warpgate."+e,t)}static canSpawn(e){return s.canUser(e,["TOKEN_CREATE","TOKEN_CONFIGURE","FILES_BROWSE"])}static canMutate(e){return s.canUser(e,["TOKEN_CONFIGURE","FILES_BROWSE"])}static async handleNotice({x:e,y:t},a,s){if(canvas.ready&&a&&s&&s.receivers.includes(game.userId)&&canvas.scene?.id===a){const i={},n=void 0!==e&&void 0!==t,r=!!s.pan,o=!!s.zoom,c=!!s.ping;if(n&&(i.x=e,i.y=t),r&&(i.duration=Number.isNumeric(s.pan)&&!0!==s.pan?Number(s.pan):CONFIG.Canvas.pings.pullSpeed),o&&(i.scale=Math.min(CONFIG.Canvas.maxZoom,s.zoom)),r&&await canvas.animatePan(i),c&&n){const e=game.users.get(s.sender),t={x:i.x,y:i.y};canvas.isOffscreen(t)?canvas.controls.drawOffscreenPing(t,{scene:a,style:CONFIG.Canvas.pings.types.ARROW,user:e}):canvas.controls.drawPing(t,{scene:a,style:s.ping,user:e})}}}static canUser(e,t){if(s.setting("disablePermCheck"))return[];const{role:a}=e,i=game.settings.get("core","permissions");return t.filter((e=>!i[e].includes(a))).map((e=>game.i18n.localize(CONST.USER_PERMISSIONS[e].label)))}static firstGM(){return game.users?.find((e=>e.isGM&&e.active))}static isFirstGM(){return game.user?.id===s.firstGM()?.id}static emptyObject(e){return foundry.utils.isEmpty(e)}static removeEmptyObjects(e){let t=foundry.utils.flattenObject(e);return Object.keys(t).forEach((e=>{"object"==typeof t[e]&&s.emptyObject(t[e])&&delete t[e]})),foundry.utils.expandObject(t)}static copy(t,a="error.unknown"){try{return foundry.utils.deepClone(t,{strict:!0})}catch(t){e.catchThrow(t,s.localize(a))}}static stripEmpty(e,t=!0){const a=t?e:s.copy(e);return Object.keys(a).forEach((e=>{"object"==typeof a[e]&&s.emptyObject(a[e])&&delete a[e]})),a}static ownerSublist(e){return e.reduce(((e,t)=>{if(!t)return e;const a=s.firstOwner(t)?.id??"none";return e[a]??=[],e[a].push(t),e}),{})}static firstOwner(e){if(!e)return;const t=e instanceof TokenDocument?e.actor:e instanceof Token?e.document.actor:e,a=getProperty(t??{},"ownership")??{},i=Object.entries(a).filter((([e,t])=>!game.users.get(e)?.isGM&&game.users.get(e)?.active&&3===t)).map((([e])=>e));return i.length>0?game.users.get(i[0]):s.firstGM()}static isFirstOwner(e){return game.user.id===s.firstOwner(e).id}static async wait(e){return new Promise((t=>setTimeout(t,e)))}static async waitFor(e,t=600,a=100,i=0){for(;!e(i,i*a/100)&&(t<0||i<t);)i++,await s.wait(a);return i!==t}static settings(){const e={disablePermCheck:{config:!0,scope:"world",type:Boolean,default:!1}};s.applySettings(e)}static applySettings(e){Object.entries(e).forEach((([e,t])=>{game.settings.register(s.data.name,e,{name:s.localize(`setting.${e}.name`),hint:s.localize(`setting.${e}.hint`),...t})}))}static async getTokenData(t,a){let s=t;if("string"==typeof t&&(s=game.actors.getName(t)),!s)return e.error(`Could not find world actor named "${t}" or no souce actor document provided.`),!1;let i=await s.getTokenDocument(a);return i?(await loadTexture(i.texture.src),i):(e.error("Could not find proto token data for "+s.name),!1)}static async updateProtoToken(e,t){e.updateSource(t);const a=getProperty(t,"texture.src");a&&await loadTexture(a)}static getMouseStagePos(){return s.compat("interaction.pointer").getLocalPosition(canvas.app.stage)}static shimUpdate(e){e.token=s.shimClassData(TokenDocument.implementation,e.token),e.actor=s.shimClassData(Actor.implementation,e.actor),Object.keys(e.embedded??{}).forEach((t=>{const a=CONFIG[t].documentClass;Object.entries(e.embedded[t]).forEach((([i,n])=>{e.embedded[t][i]="string"==typeof n?n:s.shimClassData(a,n)}))}))}static shimClassData(e,t){return t?t&&!foundry.utils.isEmpty(t)?e.migrateData(foundry.utils.expandObject(t)):foundry.utils.expandObject(t):t}static getFeedbackSettings({alwaysAccept:e=!1,suppressToast:t=!1}={}){const a=0==s.setting("alwaysAcceptLocal")?s.setting("alwaysAccept"):{1:!0,2:!1}[s.setting("alwaysAcceptLocal")],i=!!e||a,n=0==s.setting("suppressToastLocal")?s.setting("suppressToast"):{1:!0,2:!1}[s.setting("suppressToastLocal")];return{alwaysAccept:i,suppressToast:!!t||n}}static strictUpdateDiff(e,t){const a=foundry.utils.flattenObject(foundry.utils.diffObject(e,t,{inner:!0})),i=s.unique(flattenObject(e),flattenObject(t));return Object.keys(i).forEach((e=>{"object"!=typeof i[e]&&(a[e]=null)})),foundry.utils.expandObject(a)}static unique(e,t){const a=getType(e),s=getType(t);if("Object"!==a||"Object"!==s)throw Error("One of source or template are not Objects!");const i=function(e,t,a){for(let[s,n]of Object.entries(e)){let e=t.hasOwnProperty(s),r=t[s];e&&"Object"===getType(n)&&"Object"===getType(r)?a[s]=i(n,r,{}):e||(a[s]=n)}return a};return i(e,t,{})}static async buttonDialog(e,t="row"){return await new Promise((async a=>{let s,i={};e.buttons.forEach((e=>{i[e.label]={label:e.label,callback:()=>a(e.value)}})),s=new Dialog({title:e.title??"",content:e.content??"",buttons:i,close:()=>a(!1)},{height:"100%",...e.options}),await s._render(!0),s.element.find(".dialog-buttons").css({"flex-direction":t})}))}static dialogInputs=t=>(t.forEach((t=>{"select"===t.type&&t.options.forEach(((a,i)=>{switch(typeof a){case"string":t.options[i]={value:a,html:a};case"object":if(t.options[i].html??=t.options[i].value,t.options[i].html&&null!=t.options[i].value)break;default:{const t=s.format("error.badSelectOpts",{fnName:"menu"});throw e.error(t),Error(t)}}}))})),`\n<table style="width:100%">\n  ${t.map((({type:e,label:t,value:a,options:s},i)=>{switch(e=e.toLowerCase()){case"header":return`<tr><td colspan = "2"><h2>${t}</h2></td></tr>`;case"button":return"";case"info":return`<tr><td colspan="2">${t}</td></tr>`;case"select":{const e=s.map(((e,t)=>`<option value="${t}">${e.html}</option>`)).join("");return`<tr><th style="width:50%"><label>${t}</label></th><td style="width:50%"><select id="${i}qd">${e}</select></td></tr>`}case"radio":return`<tr><th style="width:50%"><label>${t}</label></th><td style="width:50%"><input type="${e}" id="${i}qd" ${s instanceof Array&&s[1]?"checked":""} value="${a??t}" name="${s instanceof Array?s[0]:s??"radio"}"/></td></tr>`;case"checkbox":return`<tr><th style="width:50%"><label>${t}</label></th><td style="width:50%"><input type="${e}" id="${i}qd" ${(s instanceof Array?s[0]:s)?"checked":""} value="${a??t}"/></td></tr>`;default:return`<tr><th style="width:50%"><label>${t}</label></th><td style="width:50%"><input type="${e}" id="${i}qd" value="${s instanceof Array?s[0]:s}"/></td></tr>`}})).join("")}\n</table>`);static async dialog(t={},a="Prompt",s="Ok"){e.warn("'warpgate.dialog' is deprecated and will be removed in version 1.17.0. See 'warpgate.menu' as a replacement."),t=t instanceof Array?t:[t];const i=await warpgate.menu({inputs:t},{title:a,defaultButton:s});return!1!==i.buttons&&i.inputs}static async menu(e={},t={}){const{title:a,defaultButton:i,render:n,close:r,options:o}=foundry.utils.mergeObject({title:"Prompt",defaultButton:"Ok",render:null,close:e=>e({buttons:!1}),options:{}},t),{inputs:c,buttons:l}=foundry.utils.mergeObject({inputs:[],buttons:[]},e);return await new Promise((e=>{let t=s.dialogInputs(c),d={};l.forEach((t=>{d[t.label]={label:t.label,callback:async a=>{const i={inputs:s._innerValueParse(c,a),buttons:t.value};t.callback instanceof Function&&await t.callback(i,t,a),e(i)}}})),l.length<1&&(d={Ok:{label:i,callback:t=>e({inputs:s._innerValueParse(c,t),buttons:!0})}}),new Dialog({title:a,content:t,close:(...t)=>r(e,...t),buttons:d,render:n},{focus:!0,...o}).render(!0)}))}static _innerValueParse(e,t){return Array(e.length).fill().map(((a,s)=>{let{type:i}=e[s];if("select"===i.toLowerCase())return e[s].options[t.find(`select#${s}qd`).val()].value;switch(i.toLowerCase()){case"text":case"password":return t.find(`input#${s}qd`)[0].value;case"radio":case"checkbox":return!!t.find(`input#${s}qd`)[0].checked&&t.find(`input#${s}qd`)[0].value;case"number":return t.find(`input#${s}qd`)[0].valueAsNumber}}))}}class i extends MeasuredTemplate{constructor(e,t={}){const a={t:e.t??"circle",user:game.user.id,distance:e.size,x:e.x,y:e.y,fillColor:e.fillColor,width:1,texture:e.texture,direction:e.direction};super(new CONFIG.MeasuredTemplate.documentClass(a,{parent:canvas.scene})),this.icon=e.icon??i.ERROR_TEXTURE,this.label=e.label,this.labelOffset=e.labelOffset,this.tag=e.tag,this.drawIcon=e.drawIcon,this.drawOutline=e.drawOutline,this.fillAlpha=e.fillAlpha,this.tileTexture=e.tileTexture,this.lockSize=e.lockSize,this.lockPosition=e.lockPosition,this.interval=e.interval,this.callbacks=t,this.inFlight=!1,this.cancelled=!0,this.rightX=0,this.rightY=0,this.radius=this.document.distance*this.scene.grid.size/2}toObject(){const e=foundry.utils.mergeObject(this.document.toObject(),{cancelled:this.cancelled,scene:this.scene,radius:this.radius,size:this.document.distance});return delete e.width,e}static ERROR_TEXTURE="icons/svg/hazard.svg";static getTag(e){return canvas.templates.preview.children.find((t=>t.tag===e))}static getSnappedPosition({x:e,y:t},a){const s=a<0?canvas.grid.size/2:0,i=canvas.grid.getSnappedPosition(e-s,t-s,a);return{x:i.x+s,y:i.y+s}}_setRulerText(){this.ruler.text=this.label,this.ruler.position.set(-this.ruler.width/2+this.labelOffset.x,this.template.height/2+5+this.labelOffset.y)}async draw(){this.clear();const e=this.document.texture;return this._texture=e?await loadTexture(e,{fallback:"icons/svg/hazard.svg"}):null,this.template=this.addChild(new PIXI.Graphics),this.controlIcon=this.addChild(this._drawControlIcon()),this.ruler=this.addChild(this._drawRulerText()),this.refresh(),this._setRulerText(),this.id&&this.activateListeners(),this}_drawRulerText(){const e=CONFIG.canvasTextStyle.clone();e.fontSize=Math.max(Math.round(.36*canvas.dimensions.size*12)/12,36);const t=new PreciseText(null,e);return t.anchor.set(0,0),t}_drawControlIcon(){const e=Math.max(20*Math.round(.5*canvas.dimensions.size/20),40);let t=new ControlIcon({texture:this.icon,size:e});return t.visible=this.drawIcon,t.pivot.set(.5*e,.5*e),t.angle=this.document.direction,t}refresh(){if(!this.template)return;let e=canvas.dimensions;const t=this.document;this.position.set(t.x,t.y);let{direction:a,distance:i}=t;if(i*=e.size/2,a=Math.toRadians(a),this.ray=Ray.fromAngle(t.x,t.y,a,i),this.shape=s.compat("crosshairs.computeShape",this),this.template.clear().lineStyle(this._borderThickness,this.borderColor,this.drawOutline?.75:0),this._texture){const e=this.tileTexture?1:2*i/this._texture.width,t=this.tileTexture?0:i;this.template.beginTextureFill({texture:this._texture,matrix:(new PIXI.Matrix).scale(e,e).translate(-t,-t)})}else this.template.beginFill(this.fillColor,this.fillAlpha);return this.template.drawShape(this.shape),this.drawIcon&&(this.controlIcon.visible=!0,this.controlIcon.border.visible=this._hover,this.controlIcon.angle=t.direction),this._setRulerText(),this}async drawPreview(){return this.initialLayer=canvas.activeLayer,this.layer.activate(),this.draw(),this.layer.preview.addChild(this),this.layer.interactiveChildren=!1,this.inFlight=!0,this.activatePreviewListeners(),this.callbacks?.show?.(this),await s.waitFor((()=>!this.inFlight),-1),this.activeHandlers&&this.clearHandlers(),this}_mouseMoveHandler(e){if(e.stopPropagation(),this.lockPosition)return;let t=Date.now();if(t-this.moveTime<=20)return;const a=e.data.getLocalPosition(this.layer),{x:s,y:n}=i.getSnappedPosition(a,this.interval);this.document.updateSource({x:s,y:n}),this.refresh(),this.moveTime=t,canvas._onDragCanvasPan(e.data.originalEvent)}_leftClickHandler(e){const t=this.document,a=this.scene.grid.size,s=i.getSnappedPosition(this.document,this.interval);this.radius=t.distance*a/2,this.cancelled=!1,this.document.updateSource({...s}),this.clearHandlers(e)}_mouseWheelHandler(e){e.ctrlKey&&e.preventDefault(),e.altKey||e.stopPropagation();const t=canvas.grid.type>CONST.GRID_TYPES.SQUARE?30:15,a=e.ctrlKey?t:5,s=this.document,i=this.scene.grid.size;if(e.shiftKey&&!this.lockSize){let t=s.distance+.25*Math.sign(e.deltaY);t=Math.max(t,.25),this.document.updateSource({distance:t}),this.radius=s.distance*i/2}else if(!e.altKey){const t=s.direction+a*Math.sign(e.deltaY);this.document.updateSource({direction:t})}this.refresh()}_rightDownHandler(e){2===e.button&&(this.rightX=e.screenX,this.rightY=e.screenY)}_rightUpHandler(e){if(2!==e.button)return;const t=(e,t)=>Math.abs(e-t)<10;t(this.rightX,e.screenX)&&t(this.rightY,e.screenY)&&(this.cancelled=!0,this.clearHandlers(e))}_clearHandlers(e){this.layer.preview.removeChild(this),canvas.stage.off("mousemove",this.activeMoveHandler),canvas.stage.off("mousedown",this.activeLeftClickHandler),canvas.app.view.onmousedown=null,canvas.app.view.onmouseup=null,canvas.app.view.onwheel=null,this.layer.interactiveChildren=!0,0==this.layer.preview.children.length&&this.initialLayer.activate(),this.actorSheet&&this.actorSheet.maximize(),this.activeHandlers=!1,this.inFlight=!1,this._destroyed=!0}activatePreviewListeners(){this.moveTime=0,this.activeHandlers=!0,this.activeMoveHandler=this._mouseMoveHandler.bind(this),this.activeLeftClickHandler=this._leftClickHandler.bind(this),this.rightDownHandler=this._rightDownHandler.bind(this),this.rightUpHandler=this._rightUpHandler.bind(this),this.activeWheelHandler=this._mouseWheelHandler.bind(this),this.clearHandlers=this._clearHandlers.bind(this),canvas.stage.on("mousemove",this.activeMoveHandler),canvas.stage.on("mousedown",this.activeLeftClickHandler),canvas.app.view.onwheel=this.activeWheelHandler,canvas.app.view.onmousedown=this.rightDownHandler,canvas.app.view.onmouseup=this.rightUpHandler}}const n="Events";let r={},o={},c=0;Array.prototype.removeIf=function(e){let t=this.length;for(;t--;)if(e(this[t],t))return this.splice(t,1),!0;return!1};class l{static watch(e,t,a=(()=>!0)){return r[e]||(r[e]=[]),c++,r[e].push({fn:t,condition:a,id:c}),c}static trigger(e,t,a=(()=>!0)){return o[e]||(o[e]=[]),c++,o[e].push({fn:t,condition:a,id:c}),c}static async run(t,a){for(const{fn:s,condition:i,id:o}of r[t]??[])try{i(a)?(e.debug(`${t} | ${o} passes watch condition`),await s(a)):e.debug(`${t} | ${o} fails watch condition`)}catch(a){e.error(n+" | error",a,`\n \nIn watch function (${t})\n`,s)}let{run:s,keep:i}=(o[t]??[]).reduce(((s,i)=>{try{i.condition(a)?(e.debug(`${t} | ${i.id} passes trigger condition`),s.run.push(i)):(e.debug(`${t} | ${i.id} fails trigger condition`),s.keep.push(i))}catch(a){return e.error(n+" | error",a,`\n \nIn trigger condition function (${t})\n`,i.condition),s}finally{return s}}),{run:[],keep:[]});for(const{fn:i,id:r}of s){e.debug(`${t} | calling trigger ${r}`);try{await i(a)}catch(a){e.error(n+" | error",a,`\n \nIn trigger function (${t})\n`,i)}}o[t]=i}static remove(e){const t=t=>t.id===e,a=e=>e.removeIf(t),s=Object.values(r).map(a).reduce(((e,t)=>e||t),!1),i=Object.values(o).map(a).reduce(((e,t)=>e||t),!1);return s||i}}const d="Mutator";class u{static register(){u.defaults()}static defaults(){s[d]={comparisonKey:"name"}}static#e(e,t,a){return this.#t(e,t,a)?.id??null}static#t(e,t,a){return e.find((e=>getProperty(e,a)===t))}static _parseUpdateShorthand(e,t,a){let s=Object.keys(t).map((s=>{if(t[s]===warpgate.CONST.DELETE)return{_id:null};const i=this.#e(e,s,a);return{...t[s],_id:i}}));return s=s.filter((e=>!!e._id)),s}static _parseDeleteShorthand(e,t,a){let s=Object.keys(t).map((s=>t[s]!==warpgate.CONST.DELETE?null:this.#e(e,s,a)));return s=s.filter((e=>!!e)),s}static _parseAddShorthand(e,t,a){return Object.keys(t).reduce(((s,i)=>{if(t[i]===warpgate.CONST.DELETE)return s;if(this.#e(e,i,a))return s;let n=t[i];return setProperty(n,a,i),s.push(n),s}),[])}static _invertShorthand(t,a,i){let n={};return Object.keys(a).forEach((r=>{const o=this.#t(t,r,i);if(a[r]!==warpgate.CONST.DELETE)if(o){const e=expandObject(a[r]),t=o.toObject(),c=mergeObject(t,e,{inplace:!1}),l=s.strictUpdateDiff(c,t);setProperty(n,c[i],l)}else setProperty(n,r,warpgate.CONST.DELETE);else o?setProperty(n,r,o.toObject()):e.debug("Delta Creation: Could not locate shorthand identified document for deletion.",t,r,a[r])})),n}static _errorCheckEmbeddedUpdates(t,a){if("Item"==t){const i=(a.add??[]).find((e=>!e.type));if(i)return e.info(i),{error:!0,message:s.format("error.badMutate.missing.type",{embeddedName:t})}}return{error:!1}}static async _performEmbeddedUpdates(t,a,s,i="name",n={}){const r=t.getEmbeddedCollection(a),o=u._parseAddShorthand(r,s,i),c=u._parseUpdateShorthand(r,s,i),l=u._parseDeleteShorthand(r,s,i);e.debug(`Modify embedded ${a} of ${t.name} from`,{adds:o,updates:c,deletes:l});const{error:d,message:p}=u._errorCheckEmbeddedUpdates(a,{add:o,update:c,delete:l});if(d)return e.error(p),!1;try{o.length>0&&await t.createEmbeddedDocuments(a,o,n)}catch(t){e.error(t)}try{c.length>0&&await t.updateEmbeddedDocuments(a,c,n)}catch(t){e.error(t)}try{l.length>0&&await t.deleteEmbeddedDocuments(a,l,n)}catch(t){e.error(t)}return!0}static async _updateEmbedded(e,t,a,i={}){t?.embedded&&delete t.embedded;for(const n of Object.keys(t??{}))await u._performEmbeddedUpdates(e,n,t[n],a[n]??s[d].comparisonKey,i[n]??{})}static async _updateActor(t,a={},i={},n={}){e.debug("Performing update on (actor/updates)",t,a,i,n),await warpgate.wait(s.setting("updateDelay")),a.actor&&await t.update(a.actor,n.actor??{}),await u._updateEmbedded(t,a.embedded,i,n.embedded)}static async mutate(t,a={},i={},n={}){const r=s.canMutate(game.user);if(r.length>0)return e.warn(s.format("error.missingPerms",{permList:r.join(", ")})),!1;if(!n.overrides?.preserveData){if(!(a=s.copy(a,"error.badUpdate.complex")))return!1;n=foundry.utils.mergeObject(n,{overrides:{preserveData:!0}},{inplace:!1})}await u.clean(a,n);let o=u._createMutateInfo(n.delta??{},n);if(warpgate.mutationStack(t).getName(o.name))return e.warn(s.format("error.badMutate.duplicate",{name:o.name})),!1;if(n.name=o.name,s.shimUpdate(a),n.permanent){if(i.delta&&!1===await i.delta({},t))return!1}else{let e=n.delta??u._createDelta(t,a,n);if(i.delta&&!1===await i.delta(e,t))return!1;o=u._mergeMutateDelta(t.actor,e,a,n),n.delta=o.delta}if(!t.actor.isOwner)return p.remoteMutate(t,{updates:a,callbacks:i,options:n});if(n.notice&&t.object){const e={scene:t.object.scene,...t.object.center};warpgate.plugin.notice(e,n.notice)}return await u._update(t,a,n),i.post&&await i.post(t,a,!0),await warpgate.event.notify(warpgate.EVENT.MUTATE,{uuid:t.uuid,updates:n.overrides?.includeRawData?a:"omitted",options:n}),o}static async batchMutate(t,{updates:a,callbacks:i,options:n}){const r=s.ownerSublist(t);(r.none??[]).length>0&&(e.warn(s.localize("error.offlineOwnerBatch")),e.debug("Affected UUIDs:",r.none.map((e=>e.uuid))),delete r.none),n.name??=randomID();let o=Reflect.ownKeys(r).flatMap((async e=>e==game.userId?await r[e].map((e=>warpgate.mutate(e,a,i,n))):await p.remoteBatchMutate(r[e],{updates:a,callbacks:i,options:n})));return o=await Promise.all(o),Promise.all(o.flat())}static async batchRevert(t,{mutationName:a=null,options:i={}}={}){const n=s.ownerSublist(t);(n.none??[]).length>0&&(e.warn(s.localize("error.offlineOwnerBatch")),e.debug("Affected UUIDs:",n.none.map((e=>e.uuid))),delete n.none);let r=Reflect.ownKeys(n).map((e=>e==game.userId?n[e].map((e=>warpgate.revert(e,a,i))):p.remoteBatchRevert(n[e],{mutationName:a,options:i})));return r=await Promise.all(r),Promise.all(r.flat())}static _createMutateInfo(e,t={}){return t.name??=randomID(),{delta:s.stripEmpty(e),user:game.user.id,comparisonKeys:s.stripEmpty(t.comparisonKeys??{},!1),name:t.name,updateOpts:s.stripEmpty(t.updateOpts??{},!1),overrides:s.stripEmpty(t.overrides??{},!1)}}static _cleanInner(e){Object.keys(e).forEach((t=>{"embedded"!=t&&"string"!=typeof e[t]&&(e[t]?.toObject&&(e[t]=e[t].toObject()),null==e[t]&&(e[t]={}))}))}static async clean(t,a=void 0){if(t){let a;u._cleanInner(t),Object.values(t.embedded??{}).forEach((e=>u._cleanInner(e))),"src"in(t.token?.texture??{})?a=t.token.texture.src:"img"in(t.token??{})&&(a=t.token.img);try{a&&await loadTexture(a)}catch(t){e.debug(t)}}a&&(a.comparisonKeys=foundry.utils.mergeObject(a.comparisonKeys??{},{ActiveEffect:"label"},{overwrite:!1,inplace:!1}),a.comparisonKeys??={},a.updateOpts??={},Object.keys(a.comparisonKeys).forEach((e=>{"id"==a.comparisonKeys[e]&&(a.comparisonKeys[e]="_id"),"_id"==a.comparisonKeys[e]&&foundry.utils.mergeObject(a.updateOpts,{embedded:{[e]:{keepId:!0}}})})))}static _mergeMutateDelta(e,t,a,i){let n=e.getFlag(s.data.name,"mutate")??[];const r=u._createMutateInfo(t,i);n.push(r);const o={warpgate:{mutate:n}};return a.actor=mergeObject(a.actor??{},{flags:o}),r}static async _update(e,t,a={}){return await e.update(t.token??{},a.updateOpts?.token??{}),!a.noMoveWait&&e.object&&await(CanvasAnimation.getAnimation(e.object.animationName)?.promise),u._updateActor(e.actor,t,a.comparisonKeys??{},a.updateOpts??{})}static async revertMutation(e,t=void 0,a={}){const i=await u._popMutation(e?.actor,t);if(i){if(!e.actor?.isOwner)return p.remoteRevert(e,{mutationId:i.name,options:a});if(a.notice&&e.object){const t={scene:e.object.scene,...e.object.center};warpgate.plugin.notice(t,a.notice)}if(!a.overrides?.preserveData){if(!(a=s.copy(a,"error.badUpdate.complex")))return;a=foundry.utils.mergeObject(a,{overrides:{preserveData:!0}},{inplace:!1})}return s.shimUpdate(i.delta),i.updateOpts??={},i.overrides??={},foundry.utils.mergeObject(i.updateOpts,a.updateOpts??{}),foundry.utils.mergeObject(i.overrides,a.overrides??{}),await u._update(e,i.delta,{overrides:i.overrides,comparisonKeys:i.comparisonKeys,updateOpts:i.updateOpts}),warpgate.event.notify(warpgate.EVENT.REVERT,{uuid:e.uuid,updates:a.overrides?.includeRawData?i:"omitted",options:a}),i}}static async _popMutation(t,a){let i,n=t?.getFlag(s.data.name,"mutate")??[];if(0==n.length||!t)return void e.debug("Provided actor is undefined or has no mutation stack. Cannot pop.");if(a){const r=n.findIndex((e=>e.name===a));if(r<0)return void e.debug(`Could not locate mutation named ${a} in actor ${t.name}`);i=n.splice(r,1)[0];for(let e=r;e<n.length;e++){const t=filterObject(i.delta,n[e].delta);mergeObject(n[e].delta,t),i.delta=s.unique(i.delta,n[e].delta)}}else i=n.pop();const r={[s.data.name+".mutate"]:n};return foundry.utils.mergeObject(i.delta,{actor:{flags:r}}),e.debug(s.localize("debug.finalRevertUpdate"),i),i}static _createDelta(t,a,i){let n=t.toObject();const r=s.strictUpdateDiff(a.token??{},n),o=u._getRootActorData(t.actor),c=s.strictUpdateDiff(a.actor??{},o);let l={};if(a.embedded)for(const e of Object.keys(a.embedded)){const s=t.actor.getEmbeddedCollection(e),n=u._invertShorthand(s,a.embedded[e],getProperty(i.comparisonKeys,e)??"name");l[e]=n}return e.debug(s.localize("debug.tokenDelta"),r,s.localize("debug.actorDelta"),c,s.localize("debug.embeddedDelta"),l),{token:r,actor:c,embedded:l}}static _getRootActorData(e){let t=e.toObject();return Object.values(Actor.implementation.metadata.embedded).forEach((e=>{delete t[e]})),t}}class p{static register(){p.settings()}static settings(){const e=!0,t={alwaysAccept:{scope:"world",config:e,default:!1,type:Boolean},suppressToast:{scope:"world",config:e,default:!1,type:Boolean},alwaysAcceptLocal:{scope:"client",config:e,default:0,type:Number,choices:{0:s.localize("setting.option.useWorld"),1:s.localize("setting.option.overrideTrue"),2:s.localize("setting.option.overrideFalse")}},suppressToastLocal:{scope:"client",config:e,default:0,type:Number,choices:{0:s.localize("setting.option.useWorld"),1:s.localize("setting.option.overrideTrue"),2:s.localize("setting.option.overrideFalse")}}};s.applySettings(t)}static _createMutateTriggers(e,{post:t},a){const i=t=>t.tokenId===e.id&&t.mutationId===a.name,n=new Promise((e=>{warpgate.event.trigger(warpgate.EVENT.MUTATE_RESPONSE,(async i=>{const n=game.scenes.get(i.sceneId).getEmbeddedDocument("Token",i.tokenId);if(i.accepted){const e=s.format("display.mutationAccepted",{mName:a.name,tName:n.name}),{suppressToast:t}=s.getFeedbackSettings(a.overrides);t||ui.notifications.info(e)}else{const e=s.format("display.mutationRejected",{mName:a.name,tName:n.name});a.overrides?.suppressReject||ui.notifications.warn(e)}t&&await t(n,i.updates,i.accepted),e(i)}),i)}));return n}static _createRevertTriggers(e,t=void 0,{callbacks:a={},options:i={}}){const n=a=>a.tokenId===e.id&&(a.mutationId===t||!t),r=t||warpgate.mutationStack(e).last.name,o=new Promise((async e=>{warpgate.event.trigger(warpgate.EVENT.REVERT_RESPONSE,(async t=>{const n=game.scenes.get(t.sceneId).getEmbeddedDocument("Token",t.tokenId);if(t.accepted){const e=s.format("display.revertAccepted",{mName:r,tName:n.name}),{suppressToast:t}=s.getFeedbackSettings(i.overrides);t||ui.notifications.info(e)}else{const e=s.format("display.revertRejected",{mName:r,tName:n.name});i.overrides?.suppressReject||ui.notifications.warn(e)}await(a.post?.(n,t.updates,t.accepted)),e(t)}),n)}));return o}static remoteMutate(t,{updates:a,callbacks:i={},options:n={}}){if(!s.firstOwner(t))return e.error(s.localize("error.noOwningUserMutate")),!1;const r=p._createMutateTriggers(t,i,n);return k.requestMutate(t.id,t.parent.id,{updates:a,options:n}),r}static async remoteBatchMutate(e,{updates:t,callbacks:a={},options:s={}}){const i=e.shift();let n=[await warpgate.mutate(i,t,a,s)];if(n[0].accepted){const i=foundry.utils.mergeObject(s,{overrides:{alwaysAccept:!0,suppressToast:!0}},{inplace:!1});n=n.concat(e.map((e=>warpgate.mutate(e,t,a,i))))}else n=n.concat(e.map((e=>({sceneId:e.parent.id,tokenId:e.id,accepted:!1}))));return n}static remoteRevert(t,{mutationId:a=null,callbacks:i={},options:n={}}={}){if(!s.firstOwner(t))return e.error(s.format("error.noOwningUserRevert")),!1;const r=p._createRevertTriggers(t,a,{callbacks:i,options:n});return k.requestRevert(t.id,t.parent.id,{mutationId:a,options:n}),r}static async remoteBatchRevert(e,{mutationName:t=null,options:a={}}={}){let s=e.shift();for(;s&&0==warpgate.mutationStack(s).stack.length;)s=e.shift();if(!s)return[];const i=[await warpgate.revert(s,t,a)];if(i[0].accepted){const s=foundry.utils.mergeObject(a,{overrides:{alwaysAccept:!0,suppressToast:!0}},{inplace:!1});i.push(...e.map((e=>warpgate.revert(e,t,s))))}else i.push(...e.map((e=>({sceneId:e.parent.id,tokenId:e.id,accepted:!1}))));return i}static async handleMutationRequest(e){const t=game.scenes.get(e.sceneId).getEmbeddedDocument("Token",e.tokenId);if(s.isFirstOwner(t.actor)){let{alwaysAccept:a,suppressToast:i}=s.getFeedbackSettings(e.options.overrides);a||(a=await p._queryRequest(t,e.userId,e.options.description,e.updates),i=!0);let n={sceneId:e.sceneId,userId:game.user.id,accepted:a,tokenId:e.tokenId,mutationId:e.options.name,options:e.options};if(await warpgate.event.notify(warpgate.EVENT.MUTATE_RESPONSE,n),a){await u.mutate(t,e.updates,{},e.options);const a=s.format("display.mutationRequestTitle",{userName:game.users.get(e.userId).name,tokenName:t.name});i||ui.notifications.info(a)}}}static async handleRevertRequest(e){const t=game.scenes.get(e.sceneId).getEmbeddedDocument("Token",e.tokenId);if(s.isFirstOwner(t.actor)){const a=warpgate.mutationStack(t);if(0==(a.stack??[]).length)return;const i=e.mutationId?a.getName(e.mutationId):a.last,n=s.format("display.revertRequestDescription",{mName:i.name,tName:t.name});let{alwaysAccept:r,suppressToast:o}=s.getFeedbackSettings(e.options.overrides);r||(r=await p._queryRequest(t,e.userId,n,i),o=!0);let c={sceneId:e.sceneId,userId:game.user.id,accepted:r,tokenId:e.tokenId,mutationId:e.mutationId};await warpgate.event.notify(warpgate.EVENT.REVERT_RESPONSE,c),r&&(await u.revertMutation(t,e.mutationId,e.options),o||ui.notifications.info(n))}}static async _queryRequest(e,t,a="warpgate.display.emptyDescription",i){let n=duplicate(i);n.actor?.flags?.warpgate&&(n.actor.flags.warpgate={}),n=s.removeEmptyObjects(n);const r=p._convertObjToHTML(n),o={description:{label:s.localize("display.inspectLabel"),value:"inspect",content:`<p>${game.i18n.localize(a)}</p>`},inspect:{label:s.localize("display.descriptionLabel"),value:"description",content:r}},c=s.format("display.mutationRequestTitle",{userName:game.users.get(t).name,tokenName:e.name});let l=!1,d=o.description;do{l=await warpgate.buttonDialog({buttons:[{label:s.localize("display.findTargetLabel"),value:"select"},{label:s.localize("display.acceptLabel"),value:!0},{label:s.localize("display.rejectLabel"),value:!1},d],content:d.content,title:c,options:{top:100}}),"select"===l?e.object&&(e.object.control({releaseOthers:!0}),await canvas.animatePan({x:e.object.x,y:e.object.y})):!1!==l&&!0!==l&&(d=o[l])}while(!1!==l&&!0!==l);return l}static _convertObjToHTML(e){return JSON.stringify(e,void 0,"$SPACING").replaceAll("\n","<br>").replaceAll("$SPACING","&nbsp;&nbsp;&nbsp;&nbsp;")}}let m=new Map;function h(e){(function(e="default"){return m.has(e)||m.set(e,new g(e)),m.get(e)})().queueUpdate(e)}class g{constructor(e){this.entityType=e,this.queue=[],this.inFlight=!1}queueUpdate(e){this.queue.push(e),this.inFlight||this.runUpdate()}flush(){return s.waitFor((()=>!this.inFlight))}async runUpdate(){for(this.inFlight=!0;this.queue.length>0;){const e=this.queue.length-1,t=this.queue[e];await t(),this.queue.splice(e,1)}this.inFlight=!1}}const f="dismiss",w="event",y="req-mutate",b="req-revert",v="req-notice";class k{static register(){k.hooks()}static hooks(){Hooks.on("ready",k._ready)}static _ready(){e.info("Registering sockets"),game.socket.on("module."+s.data.name,k._receiveSocket)}static _receiveSocket(t){return e.debug("Received socket data => ",t),t.op==v?(s.handleNotice(t.payload.location,t.payload.sceneId,t.payload.options),t):(h((async()=>{switch(e.debug("Routing operation: ",t.op),t.op){case f:s.isFirstGM()&&await T.dismissSpawn(t.payload.tokenId,t.payload.sceneId,t.payload.userId);break;case w:await l.run(t.eventName,t.payload);break;case y:await p.handleMutationRequest(t.payload);break;case b:await p.handleRevertRequest(t.payload);break;default:e.error("Unrecognized socket request",t)}})),t)}static _emit(e){return game.socket.emit("module."+s.data.name,e),k._receiveSocket(e)}static requestDismissSpawn(e,t){const a={op:f,payload:{tokenId:e,sceneId:t,userId:game.user.id}};return k._emit(a)}static requestMutate(e,t,{updates:a={},options:s={}}={},i=game.user.id){const n={op:y,payload:{userId:i,tokenId:e,sceneId:t,updates:a,options:s}};return k._emit(n)}static requestRevert(e,t,{mutationId:a,onBehalf:s=game.user.id,options:i={}}){const n={op:b,payload:{userId:s,tokenId:e,sceneId:t,mutationId:a,options:i}};return k._emit(n)}static requestNotice(e,t=canvas.scene?.id,a={}){const s={op:v,payload:{sceneId:t,location:e,options:a}};return k._emit(s)}static packToken(e){const t=e.toObject();delete t.actorData;let a=e.actor?.toObject()??{};return a.token=t,a}static notifyEvent(e,t={},a=game.user.id){t.sceneId=canvas.scene.id,t.userId=a;const s={op:w,eventName:e,payload:t};return k._emit(s)}}class O{static getFreePosition(e,t,a=!0){const s=canvas.grid.getCenter(t.x,t.y);t={x:s[0],y:s[1]};const i=O.generatePositions(t);for(let t of i)if(O.canFit(e,t,i[0],a))return t}static generatePositions(e){let t=[canvas.grid.getSnappedPosition(e.x-1,e.y-1)];for(let a=canvas.scene.dimensions.size;a<10*canvas.scene.dimensions.size;a+=canvas.scene.dimensions.size)for(let s=0;s<2*Math.PI;s+=Math.PI/(4*a/canvas.scene.dimensions.size)){const i=canvas.grid.getTopLeft(e.x+a*Math.cos(s),e.y+a*Math.sin(s));t.push({x:i[0],y:i[1]})}return t}static isFree(e){for(let t of canvas.tokens.placeables)if(new PIXI.Rectangle(t.x,t.y,t.w,t.h).contains(e.x,e.y))return!1;return!0}static canFit(e,t,a,s){for(let a=0;a<e.width;a++)for(let s=0;s<e.height;s++){const e=t.x+s*canvas.scene.dimensions.size,i=t.y+a*canvas.scene.dimensions.size;if(!O.isFree({x:e,y:i}))return!1}const i=canvas.walls.checkCollision(new Ray(a,{x:t.x+e.width*canvas.scene.dimensions.size/2,y:t.y+e.height*canvas.scene.dimensions.size/2}),{type:"move"})?.length??0;return!s||!i}}const E="Gateway";class T{static register(){this.settings(),this.defaults()}static settings(){const e={openDelete:{scope:"world",config:!0,default:!1,type:Boolean},updateDelay:{scope:"client",config:!0,default:0,type:Number}};s.applySettings(e)}static defaults(){s[E]={get crosshairsConfig(){return{size:1,icon:"icons/svg/dice-target.svg",label:"",labelOffset:{x:0,y:0},tag:"crosshairs",drawIcon:!0,drawOutline:!0,interval:2,fillAlpha:0,tileTexture:!1,lockSize:!0,lockPosition:!1,rememberControlled:!1,texture:null,direction:0,fillColor:game.user.color}}}}static async _rollItemGetLevel(e,t={},a={}){const s=await e.use(a,t);if(!s)return 0;const i=s.content,n=i.charAt(i.indexOf("data-spell-level")+18);return parseInt(n)}static async showCrosshairs(e={},t={}){mergeObject(e,s[E].crosshairsConfig,{overwrite:!1});let a=[];if(e.rememberControlled&&(a=canvas.tokens.controlled),!e.hasOwnProperty("x")&&!e.hasOwnProperty("y")){let t=s.getMouseStagePos();t=i.getSnappedPosition(t,e.interval),e.x=t.x,e.y=t.y}const n=new i(e,t);await n.drawPreview();const r=n.toObject();for(const e of a)e.control({releaseOthers:!1});return r}static _containsCenter(e,t){var a,s;return a=e.center,s=t,Math.hypot(a.x-s.x,a.y-s.y)<=t.radius}static collectPlaceables(e,t="Token",a=T._containsCenter){const s=t instanceof Array,i=(t=s?t:[t]).reduce(((t,s)=>{let i=e.scene.getEmbeddedCollection(s).filter((t=>a(t.object,e)));return t[s]=i,t}),{});return s?i:i[t[0]]}static async dismissSpawn(t,a=canvas.scene?.id,i=game.user.id){if(!t||!a)return void e.debug("Cannot dismiss null token or from a null scene.",t,a);const n=game.scenes.get(a)?.getEmbeddedDocument("Token",t);if(n)if(s.setting("openDelete")||n.isOwner)if(e.debug("Deleting token =>",t,"from scene =>",a),s.firstGM())if(s.isFirstGM()){const e=await game.scenes.get(a).deleteEmbeddedDocuments("Token",[t]),s=k.packToken(e[0]);await warpgate.event.notify(warpgate.EVENT.DISMISS,{actorData:s},i)}else k.requestDismissSpawn(t,a);else e.error(s.localize("error.noGm"));else e.error(s.localize("error.unownedDelete"));else e.debug(`Token [${t}] no longer exists on scene [${a}]`)}static async _spawnTokenAtLocation(t,a,i){const n=canvas.scene.grid.size;let r={x:a.x-n*(t.width/2),y:a.y-n*(t.height/2)};if(i){const a=O.getFreePosition(t,r);a?r=a:e.info(s.localize("error.noOpenLocation"))}return t.updateSource(r),canvas.scene.createEmbeddedDocuments("Token",[t])}}class S{constructor(e){if(this.actor=e instanceof TokenDocument?e.actor:e instanceof Token?e.document.actor:e instanceof Actor?e:null,!this.actor)throw Error(s.localize("error.stack.noActor"))}#a=[];#s=!0;get#i(){return this.actor?.getFlag(s.data.name,"mutate")??[]}get stack(){return this.#s?this.#i:this.#a}find(e){return this.#s?this.#i.find(e):this.#a.find(e)}#n(e){return this.#s?this.#i.findIndex(e):this.#a.findIndex(e)}getName(e){return this.find((t=>t.name===e))}get last(){return this.stack[this.stack.length-1]}update(t,a,{overwrite:i=!1}){const n=this.#n((e=>e.name===t));if(n<0)return this;if(this.#r(),i){if(!a.name)return e.error(s.localize("error.incompleteMutateInfo")),this.#s=!0,this;a.user||(a.user=game.user.id),this.#a[n]=a}else mergeObject(this.#a[n],a);return this}updateAll(e,t=(()=>!0)){return this.#r(),this.#a.forEach((a=>{t(a)&&(e=>"function"==typeof e?t=>mergeObject(t,e(t)):t=>mergeObject(t,e))(e)(a)})),this}deleteAll(e=(()=>!0)){return this.#r(),this.#a=this.#a.filter((t=>!e(t))),this}async commit(){return this.#s&&e.error(s.localize("error.stackLockedOrEmpty")),await this.actor.update({flags:{[s.data.name]:{mutate:this.#a}}}),this.#s=!0,this.#a.length=0,this}#r(){return!!this.#s&&(this.#a=duplicate(this.#i),this.#s=!1,!0)}}class I{static register(){I.globals()}static settings(){}static globals(){window[s.data.name]={spawn:I._spawn,spawnAt:I._spawnAt,dismiss:T.dismissSpawn,mutate:u.mutate,revert:u.revertMutation,mutationStack:e=>new S(e),wait:s.wait,dialog:s.dialog,menu:s.menu,buttonDialog:s.buttonDialog,util:{firstGM:s.firstGM,isFirstGM:s.isFirstGM,firstOwner:s.firstOwner,isFirstOwner:s.isFirstOwner},crosshairs:{show:T.showCrosshairs,getTag:i.getTag,collect:T.collectPlaceables},plugin:{queueUpdate:h,notice:I._notice,batchMutate:u.batchMutate,batchRevert:u.batchRevert},get dnd5e(){return foundry.utils.logCompatibilityWarning(`[${s.data.name}] System-specific namespaces and helper functions have been deprecated. Please convert to system provided functions.`,{since:1.16,until:2,details:"Migration details:\nrollItem(Item) to Item#use()"}),{rollItem:T._rollItemGetLevel}},CONST:{DELETE:"delete"},USERS:{get ALL(){return game.users.filter((e=>e.active)).map((e=>e.id))},get SELF(){return[game.userId]},get GM(){return game.users.filter((e=>e.active&&e.isGM)).map((e=>e.id))},get PLAYERS(){return game.users.filter((e=>e.active&&!e.isGM)).map((e=>e.id))}},EVENT:{PLACEMENT:"wg_placement",SPAWN:"wg_spawn",DISMISS:"wg_dismiss",REVERT:"wg_revert",MUTATE:"wg_mutate",MUTATE_RESPONSE:"wg_response_mutate",REVERT_RESPONSE:"wg_response_revert"},event:{watch:l.watch,trigger:l.trigger,remove:l.remove,notify:k.notifyEvent},abstract:{Crosshairs:i,MutationStack:S}}}static async _spawn(t,a={},i={},n={}){const r=s.canSpawn(game.user);if(r.length>0)return e.warn(s.format("error.missingPerms",{permList:r.join(", ")})),[];const o={ownership:{[game.user.id]:CONST.DOCUMENT_PERMISSION_LEVELS.OWNER}};if(!n.overrides?.preserveData){if(!(a=s.copy(a,"error.badUpdate.complex")))return[];n=foundry.utils.mergeObject(n,{overrides:{preserveData:!0}},{inplace:!1})}let c;if(s.shimUpdate(a),foundry.utils.mergeObject(a,{token:mergeObject(a.token??{},{actorData:o},{overwrite:!1})}),"string"==typeof t?c=await s.getTokenData(t,a.token):(c=t,c.updateSource(a.token??{})),!c)return;n.controllingActor?.sheet?.rendered&&n.controllingActor.sheet.minimize();const l=c.texture.src,d=a.token?.rotation??c.rotation??0,u=foundry.utils.mergeObject(n.crosshairs??{},{size:c.width,icon:l,name:c.name,direction:0},{inplace:!0,overwrite:!1});u.direction+=d;const p=await T.showCrosshairs(u,i),m={templateData:n.overrides?.includeRawData?p:{x:p.x,y:p.y,size:p.size,cancelled:p.cancelled},tokenData:n.overrides?.includeRawData?c.toObject():"omitted",options:n};if(await warpgate.event.notify(warpgate.EVENT.PLACEMENT,m),p.cancelled)return;let h={x:p.x,y:p.y};const g=p.size/c.width;return mergeObject(a,{token:{rotation:p.direction,width:p.size,height:c.height*g}}),I._spawnAt(h,c,a,i,n)}static async _spawnAt(t,a,i={},n={},r={}){const o=s.canSpawn(game.user);if(o.length>0)return e.warn(s.format("error.missingPerms",{permList:o.join(", ")})),[];if(!r.overrides?.preserveData){if(!(i=s.copy(i,"error.badUpdate.complex")))return[];r=foundry.utils.mergeObject(r,{overrides:{preserveData:!0}},{inplace:!1})}if(s.shimUpdate(i),"string"==typeof a&&(a=await s.getTokenData(a,i.token??{})),!a)return[];let c=[];const l={[s.data.name]:{control:{user:game.user.id,actor:r.controllingActor?.uuid}}},d={ownership:{[game.user.id]:CONST.DOCUMENT_PERMISSION_LEVELS.OWNER}};i.actor=mergeObject({flags:l,...d},i.actor??{},{inplace:!1});const p=r.duplicates>0?r.duplicates:1;u.clean(null,r),r.notice&&warpgate.plugin.notice({...t,scene:canvas.scene},r.notice);for(let o=0;o<p;o++){if(n.pre&&!1===await n.pre(t,i,o))continue;await u.clean(i),0==o?await s.updateProtoToken(a,i.token):a=await s.getTokenData(game.actors.get(a.actorId),i.token),e.debug(`Spawn iteration ${o} using`,a,i);const l=(await T._spawnTokenAtLocation(a,t,r.collision??r.duplicates>1))[0];c.push(l.id),e.debug("Spawned token with data: ",l),await u._updateActor(l.actor,i,r.comparisonKeys??{});const d={uuid:l.uuid,updates:r.overrides?.includeRawData?i:"omitted",options:r,iteration:o};if(await warpgate.event.notify(warpgate.EVENT.SPAWN,d),n.post&&!1===await n.post(t,l,i,o))break}return r.controllingActor?.sheet?.rendered&&r.controllingActor?.sheet?.maximize(),c}static _notice({x:e,y:t,scene:a},s={}){return s.sender??=game.userId,s.receivers??=warpgate.USERS.SELF,a??=canvas.scene,k.requestNotice({x:e,y:t},a.id,s)}}class _{static register(){this.hooks(),this.settings()}static hooks(){Hooks.on("renderActorSheet",_._renderActorSheet)}static settings(){const e=!0,t={showDismissLabel:{scope:"client",config:e,default:!0,type:Boolean},showRevertLabel:{scope:"client",config:e,default:!0,type:Boolean},dismissButtonScope:{scope:"client",config:e,default:"spawned",type:String,choices:{disabled:s.localize("setting.option.disabled"),spawned:s.localize("setting.option.spawnedOnly"),all:s.localize("setting.option.all")}},revertButtonBehavior:{scope:"client",config:e,default:"pop",type:String,choices:{disabled:s.localize("setting.option.disabled"),pop:s.localize("setting.option.popLatestMutation"),menu:s.localize("setting.option.showMutationList")}}};s.applySettings(t)}static _renderActorSheet(e,t,a){_.addDismissButton(e,t),_.addRevertMutation(e,t)}static _shouldAddDismiss(e){if(!(e instanceof TokenDocument))return!1;switch(s.setting("dismissButtonScope")){case"disabled":return!1;case"spawned":const t=e?.actor.getFlag(s.data.name,"control");return!(t?.user!==game.user.id&&!game.user.isGM||!t);case"all":return!0}}static addDismissButton(t,a){const i=t.token;if(!_._shouldAddDismiss(i))return;if(0!==a.closest(".app").find(".dismiss-warpgate").length)return void e.debug(s.localize("debug.dismissPresent"));const n=s.setting("showDismissLabel")?s.localize("display.dismiss"):"";let r=$(`<a class="dismiss-warpgate" title="${s.localize("display.dismiss")}"><i class="fas fa-user-slash"></i>${n}</a>`);r.click((()=>{if(!i)return void e.error(s.localize("error.sheetNoToken"));const{id:a,parent:n}=i;T.dismissSpawn(a,n?.id),t?.close({submit:!1})}));let o=a.closest(".app").find(".window-title");r.insertAfter(o)}static _shouldAddRevert(e){return e instanceof TokenDocument&&0!=warpgate.mutationStack(e).stack.length&&"disabled"!==s.setting("revertButtonBehavior")}static _getTokenFromApp(e){const{token:t,actor:a}=e;if(!(t instanceof TokenDocument)){const e=a?.getActiveTokens()??[];return e.find((e=>e.document.actorLink))?.document??null}return t}static addRevertMutation(e,t){let a=t.closest(".app").find(".revert-warpgate");a&&a.remove();const i=_._getTokenFromApp(e);if(!_._shouldAddRevert(i))return;const n=i?.actor?.getFlag(s.data.name,"mutate"),r=s.setting("showRevertLabel")?s.localize("display.revert"):"",o=n.length>1?" 1/"+n.length:"";let c=$(`<a class="revert-warpgate" title="${s.localize("display.revert")}${o}"><i class="fas fa-undo-alt"></i>${r}</a>`);c.click((async t=>{let a;var r;if(r=t.shiftKey,"menu"==s.setting("revertButtonBehavior")?!r:r){const e=n.map((e=>({label:e.name,value:e.name})));if(a=await warpgate.buttonDialog({buttons:e,title:s.localize("display.revertDialogTitle")},"column"),!1===a)return}h((async()=>{await u.revertMutation(i,a),e?.render(!1)}))}));let l=t.closest(".app").find(".window-title");c.insertAfter(l)}}const j={MODULE:s,logger:e,api:I,Gateway:T,Mutator:u,RemoteMutator:p,UserInterface:_,Comms:k};s.build(),Hooks.on("setup",(()=>{Object.values(j).forEach((e=>e.register()))}));
//# sourceMappingURL=warpgate.js.map
